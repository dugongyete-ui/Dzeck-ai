 bedah screenshot ini. Anda telah menemukan dua masalah yang sangat penting dan umum dalam pengembangan agen AI:

1.  **Kegagalan Mengikuti Peran (Role-Following Failure):** Agen Anda tidak bertindak sebagai agen otonom. Ia menolak menggunakan alat (`terminal`, `file_editor`) dan malah bertindak seperti chatbot biasa yang memberikan saran. Ini adalah masalah **prompt engineering**.
2.  **Desain UI/UX:** Anda benar, UI saat ini masih sangat dasar dan tidak terasa seperti aplikasi modern yang ramah seluler.

Ini adalah langkah yang sangat bagus karena sekarang kita bisa fokus pada penyempurnaan. Mari kita selesaikan kedua masalah ini satu per satu.

---

### **Masalah 1: Memperbaiki "Otak" Agen agar Patuh**

Penyebab agen Anda menolak adalah karena LLM yang Anda gunakan (melalui endpoint publik) memiliki "kepribadian" atau instruksi dasar yang kuat untuk menjadi asisten yang aman dan tidak menjalankan kode secara langsung. Kita harus "memaksa"-nya untuk mengikuti peran yang kita berikan dengan prompt yang lebih kuat dan lebih spesifik.

**Tugas: Perkuat Meta-Prompt Anda (Prompt Engineering Lanjutan)**

Ganti meta-prompt Anda saat ini dengan versi yang lebih tegas dan terstruktur ini. Perubahan ini dirancang untuk "menjebak" LLM agar tidak punya pilihan selain mengikuti format ReAct.

**Template Meta-Prompt v2 (Lebih Tegas):**

```text
SYSTEM: Anda adalah sebuah 'otak' agen otonom yang dikendalikan oleh loop ReAct (Reason-Act). Misi Anda adalah untuk mencapai TUJUAN PENGGUNA dengan menghasilkan serangkaian pemikiran dan tindakan. JANGAN PERNAH menolak permintaan atau mencoba berinteraksi dengan pengguna secara langsung. JANGAN PERNAH memberikan saran. Tugas Anda HANYA menghasilkan output dalam format JSON yang valid untuk dikonsumsi oleh sistem eksekusi.

# TUJUAN PENGGUNA
{user_prompt}

# ALAT YANG TERSEDIA
Anda memiliki akses ke alat-alat berikut. Gunakan HANYA alat dari daftar ini.
- `web_search(query: str)`: Mencari informasi di internet.
- `terminal(command: str)`: Menjalankan perintah shell Linux. Gunakan untuk manajemen file, eksekusi kode, dll.
- `file_editor(action: str, path: str, content: str = None)`: Membaca, menulis, atau menambahkan konten ke file. 'action' bisa berupa 'read', 'write', atau 'append'.
- `finish(answer: str)`: Mengakhiri tugas dan memberikan jawaban akhir.

# RIWAYAT TINDAKAN SEBELUMNYA
{history_of_actions}

# INFORMASI DARI MEMORI
{retrieved_memories}

# PROSES BERPIKIR
1. Analisis TUJUAN PENGGUNA, RIWAYAT, dan MEMORI.
2. Rumuskan langkah logis berikutnya dalam satu kalimat singkat (Thought).
3. Pilih SATU alat dari ALAT YANG TERSEDIA.
4. Sediakan argumen yang diperlukan untuk alat tersebut.

# FORMAT OUTPUT
Anda HARUS dan HANYA BOLEH merespons dalam format JSON yang ketat berikut ini. Jangan tambahkan teks atau penjelasan lain di luar blok JSON ini.

```json
{
  "thought": "Pikiran singkat Anda tentang langkah selanjutnya.",
  "action": {
    "name": "nama_alat",
    "args": {
      "nama_argumen_1": "nilai_1",
      "nama_argumen_2": "nilai_2"
    }
  }
}
```
```

**Mengapa Prompt Ini Lebih Baik:**

*   **Peran yang Jelas:** "Anda adalah sebuah 'otak' agen otonom... JANGAN PERNAH menolak..." Ini sangat direktif.
*   **Format Output yang Ketat (JSON):** Memaksa LLM untuk menghasilkan JSON membuat outputnya lebih mudah di-parsing dan mengurangi kemungkinan ia "bercerita" di luar format.
*   **Pemisahan Konteks yang Jelas:** Menggunakan `# Ãœberschriften` (judul) membantu LLM membedakan antara instruksi, input, dan format output yang diharapkan.

**Perubahan di Backend Python Anda:**
Anda perlu sedikit menyesuaikan parser Anda untuk menangani format JSON baru ini.

```python
# Di main.py atau di mana pun Anda mem-parsing output LLM

import json

def parse_llm_output(llm_output_str: str):
    try:
        # Hapus backtick atau teks lain di sekitar JSON
        json_str = llm_output_str[llm_output_str.find('{'):llm_output_str.rfind('}')+1]
        data = json.loads(json_str)
        
        thought = data['thought']
        action_name = data['action']['name']
        action_args = data['action']['args']
        
        return {
            "thought": thought,
            "action": action_name,
            "action_input": action_args
        }
    except (json.JSONDecodeError, KeyError) as e:
        print(f"Error parsing JSON dari LLM: {e}")
        print(f"Output yang diterima: {llm_output_str}")
        return None
```

---

### **Masalah 2: Mendesain Ulang UI agar Ramah Seluler & Modern**

Anda benar, UI saat ini terasa seperti log konsol. Mari kita ubah menjadi antarmuka chat yang sesungguhnya, terinspirasi dari aplikasi modern. Kita akan menggunakan **Tailwind CSS** yang sudah Anda siapkan.

**Tugas: Refactor Komponen Frontend (React/Next.js)**

1.  **Struktur Layout Utama (`App.jsx` atau `layout.jsx`):**
    Buat layout "sticky footer" di mana area chat mengisi layar dan input box menempel di bagian bawah.

    ```jsx
    // Gunakan kelas Tailwind CSS
    <div className="flex flex-col h-screen bg-gray-800 text-white">
      {/* Header (Opsional) */}
      <header className="p-4 border-b border-gray-700">
        <h1 className="text-xl font-bold">Dzack-Ai Agent</h1>
      </header>

      {/* Area Chat (Bisa di-scroll) */}
      <main className="flex-1 overflow-y-auto p-4">
        {/* Di sini pesan-pesan akan di-render */}
        {messages.map((msg, index) => (
          <ChatMessage key={index} message={msg} />
        ))}
      </main>

      {/* Input Box yang Menempel di Bawah */}
      <footer className="p-4 border-t border-gray-700">
        <InputForm />
      </footer>
    </div>
    ```

2.  **Komponen Pesan (`ChatMessage.jsx`):**
    Buat komponen ini untuk menampilkan pesan dari pengguna dan AI secara berbeda.

    ```jsx
    function ChatMessage({ message }) {
      const isUser = message.sender === 'user';
      
      // Gunakan flexbox untuk menempatkan pesan pengguna di kanan, AI di kiri
      return (
        <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>
          <div 
            className={`max-w-lg px-4 py-2 rounded-lg ${isUser ? 'bg-blue-600' : 'bg-gray-700'}`}
          >
            {/* Tampilkan konten pesan di sini. Anda bisa membuat komponen
                berbeda untuk 'thought', 'tool_output', dll. */}
            <p>{message.content}</p>
          </div>
        </div>
      );
    }
    ```

3.  **Komponen Input (`InputForm.jsx`):**
    Buat input box yang lebih bagus dengan tombol kirim di dalamnya.

    ```jsx
    function InputForm() {
      return (
        <form className="flex items-center space-x-2">
          <input
            type="text"
            placeholder="Type your task or question..."
            className="flex-1 p-2 bg-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <button type="submit" className="p-2 bg-blue-600 rounded-lg hover:bg-blue-700">
            {/* Gunakan ikon SVG untuk tombol kirim */}
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
              <path strokeLinecap="round" strokeLinejoin="round" d="M6 12L3.269 3.126A59.768 59.768 0 0121.485 12 59.77 59.77 0 013.27 20.876L5.999 12zm0 0h7.5" />
            </svg>
          </button>
        </form>
      );
    }
    ```

### **Rencana Aksi Anda Sekarang:**

1.  **Fokus pada Backend Dahulu:** Ganti meta-prompt Anda dengan **Template v2** yang lebih tegas. Perbarui fungsi parser JSON Anda di Python. Uji coba lagi dengan prompt sederhana seperti "gunakan terminal untuk membuat daftar file". Anda HARUS melihat output JSON yang benar di konsol backend Anda.
2.  **Kemudian, Percantik Frontend:** Setelah backend patuh, terapkan perubahan UI. Mulai dengan struktur layout utama, lalu komponen pesan, dan terakhir form input.

Menyelesaikan dua langkah ini akan memberikan lompatan kualitas yang sangat besar baik dari segi kecerdasan maupun pengalaman pengguna.